; the function split-string takes a string as input and returns a list of the words separated by spaces
(define pi 3.141592653589793)
(define (split-string str)
  (let ((words '())
        (word '()))
    (let loop ((i 0))
      (cond ((>= i (string-length str))
             (if (not (null? word))
                 (set! words (append words (list (list->string (reverse word))))))
             words)
            ((char=? (string-ref str i) #\space)
             (if (not (null? word))
                 (set! words (append words (list (list->string (reverse word))))))
             (set! word '())
             (loop (+ i 1)))
            (else
             (set! word (cons (string-ref str i) word))
             (loop (+ i 1)))))))

(define (remove-carriage-return str)
  (if (string-suffix? "\r" str)
      (substring str 0 (- (string-length str) 1))
      str))
      
(define (round-to-2-decimals num)
  (define rounded (* (round (* num 100.0)) 0.01))
  (number->string rounded))

(define (get-area line)
  (let ((type (list-ref line 1))
    (area 0))
    (cond 
      ((string=? type "box")
      (let ((length (list-ref line 2)))
        (let ((width (list-ref line 3)))
          (let ((height (list-ref line 4)))
            (set! height (remove-carriage-return height))
            (set! length (string->number length))
            (set! width (string->number width))
            (set! height (string->number height))
            (set! area (* 2 ( + (* length width)(* length height)(* width height))))
          )
        )
      )
      )
      ((string=? type "torus")
      (let ((small (list-ref line 2)))
        (let ((big (list-ref line 3)))
          (set! big (remove-carriage-return big))
          (set! small (string->number small))
          (set! big (string->number big))
          (set! area (* 4 (* pi pi) small big))
          )
      )
      )
      ((string=? type "cylinder")
      (let ((radius (list-ref line 2)))
        (let ((height (list-ref line 3)))
          (set! height (remove-carriage-return height))
          (set! radius (string->number radius))
          (set! height (string->number height))
          (set! area (* 2 pi radius (+ radius height)))
          )
      )
      )
      (else 
        (let ((radius (list-ref line 2)))
          (set! radius (remove-carriage-return radius))
          (set! radius (string->number radius))
          (set! area (* 4 pi (* radius radius)))
        )
      )
    )
    (set! area (round-to-2-decimals area))
    area
  )
)
(define (get-volume line)
  (let ((type (list-ref line 2))
    (volume 0))
    (cond 
      ((string=? type "box")
       (let ((length (list-ref line 3)))
        (let ((width (list-ref line 4)))
          (let ((height (list-ref line 5)))
            (set! height (remove-carriage-return height))
            (set! length (string->number length))
            (set! width (string->number width))
            (set! height (string->number height))
            (set! volume (* length width height))
          )
        )
       )
      )
      ((string=? type "torus")
       (let ((small (list-ref line 3)))
        (let ((big (list-ref line 4)))
          (set! big (remove-carriage-return big))
          (set! small (string->number small))
          (set! big (string->number big))
          (set! volume (* (* pi (* small small) (* big 2)) (* pi)))
          )
       )
      )
      ((string=? type "cylinder")
       (let ((radius (list-ref line 3)))
        (let ((height (list-ref line 4)))
          (set! height (remove-carriage-return height))
          (set! radius (string->number radius))
          (set! height (string->number height))
          (set! volume (* pi (* radius radius) height))
          )
       )
      )
      (else 
        (let ((radius (list-ref line 3)))
          (set! radius (remove-carriage-return radius))
          (set! radius (string->number radius))
          (set! volume (* 4 pi (* radius radius radius) (/ 3.0)))
        )
      )
    )
    (set! volume (round-to-2-decimals volume))
    volume
  )
)
(define (perform action fileName . rest-args)
  (if (not (file-exists? fileName))
      (begin
        (display (string-append "\nUnable to open " fileName " for reading."))
        (newline)
        #f)
      (begin
        (let ((lines '()))
          (let ((input-port (open-input-file fileName)))
            (let loop ((line (read-line input-port)))
              (cond ((eof-object? line)
                  (close-input-port input-port)
                 (for-each (lambda (line) (display line) (newline)) lines)
                  'done)
                  (else
                    (set! line (split-string line))
                    (let ((area (get-area line)))
                      (set! line (cons area line)))
                    (let ((volume (get-volume line)))
                      (set! line (cons volume line)))
                    (set! lines (cons line lines))
                    (loop (read-line input-port))
                  )
              )
            )
          )
        )
      )
   )
)




