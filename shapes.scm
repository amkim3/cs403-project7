(define pi 3.141592653589793)
(define (split-string x)
  (let ((line '())
        (word '()))
    (let loop ((i 0))
      (cond ((>= i (string-length x))
             (if (not (null? word))
                 (set! line (append line (list (list->string (reverse word))))))
             line)
            ((char=? (string-ref x i) #\space)
             (if (not (null? word))
                 (set! line (append line (list (list->string (reverse word))))))
             (set! word '())
             (loop (+ i 1)))
            (else
             (set! word (cons (string-ref x i) word))
             (loop (+ i 1)))))))

(define (remove-carriage-return str)
  (if (string-suffix? "\r" str)
      (substring str 0 (- (string-length str) 1))
      str))

; (define (round-to-2-decimals num)
;   (define rounded (* (round (* num 100.0)) 0.01))
;   (if (= rounded (floor rounded))
;       (string-append (number->string rounded) "00")
;       (number->string rounded)))


(define (get-area line)
  (let ((type (list-ref line 1))
    (area 0))
    (cond 
      ((string=? type "box")
      (let ((length (list-ref line 2)))
        (let ((width (list-ref line 3)))
          (let ((height (list-ref line 4)))
            (set! height (remove-carriage-return height))
            (set! length (string->number length))
            (set! width (string->number width))
            (set! height (string->number height))
            (set! area (* 2 ( + (* length width)(* length height)(* width height))))
          )
        )
      )
      )
      ((string=? type "torus")
      (let ((small (list-ref line 2)))
        (let ((big (list-ref line 3)))
          (set! big (remove-carriage-return big))
          (set! small (string->number small))
          (set! big (string->number big))
          (set! area (* 4 (* pi pi) small big))
          )
      )
      )
      ((string=? type "cylinder")
      (let ((radius (list-ref line 2)))
        (let ((height (list-ref line 3)))
          (set! height (remove-carriage-return height))
          (set! radius (string->number radius))
          (set! height (string->number height))
          (set! area (* 2 pi radius (+ radius height)))
          )
      )
      )
      (else 
        (let ((radius (list-ref line 2)))
          (set! radius (remove-carriage-return radius))
          (set! radius (string->number radius))
          (set! area (* 4 pi (* radius radius)))
        )
      )
    )
    (set! area (number->string area))
    area
  )
)
(define (get-volume line)
  (let ((type (list-ref line 2))
    (volume 0))
    (cond 
      ((string=? type "box")
       (let ((length (list-ref line 3)))
        (let ((width (list-ref line 4)))
          (let ((height (list-ref line 5)))
            (set! height (remove-carriage-return height))
            (set! length (string->number length))
            (set! width (string->number width))
            (set! height (string->number height))
            (set! volume (* length width height))
          )
        )
       )
      )
      ((string=? type "torus")
       (let ((small (list-ref line 3)))
        (let ((big (list-ref line 4)))
          (set! big (remove-carriage-return big))
          (set! small (string->number small))
          (set! big (string->number big))
          (set! volume (* (* pi (* small small) (* big 2)) (* pi)))
          )
       )
      )
      ((string=? type "cylinder")
       (let ((radius (list-ref line 3)))
        (let ((height (list-ref line 4)))
          (set! height (remove-carriage-return height))
          (set! radius (string->number radius))
          (set! height (string->number height))
          (set! volume (* pi (* radius radius) height))
          )
       )
      )
      (else 
        (let ((radius (list-ref line 3)))
          (set! radius (remove-carriage-return radius))
          (set! radius (string->number radius))
          (set! volume (* 4 pi (* radius radius radius) (/ 3.0)))
        )
      )
    )
    (set! volume (number->string volume))
    volume
  )
)
(define (check-length args)
  (if (zero? (modulo (length args) 3))
      #t
      #f
  )
)

; (define (build-string . args)
;   (string-append* args))
(define (build-string . args)
  (apply string-append args))

(define (get-info line)
  (let ((type (list-ref line 3))
    (info ""))
    (cond 
      ((string=? type "box")
       (set! info (build-string "Box: " (list-ref line 2) ", Length=" (list-ref line 4) ", Width=" (list-ref line 5) ", Height=" (remove-carriage-return(list-ref line 6)) "\n\tSurface Area: " (list-ref line 1) ", Volume: " (list-ref line 0)))
      )
      ((string=? type "torus")
       (set! info (build-string "Torus: " (list-ref line 2) ", Small Radius=" (list-ref line 4) ", Big Radius=" (remove-carriage-return(list-ref line 5)) "\n\tSurface Area: " (list-ref line 1) ", Volume: " (list-ref line 0)))
      )
      ((string=? type "cylinder")
        (set! info (build-string "Cylinder: " (list-ref line 2) ", Radius=" (list-ref line 4) ", Height=" (remove-carriage-return(list-ref line 5)) "\n\tSurface Area: " (list-ref line 1) ", Volume: " (list-ref line 0)))
      )
      (else 
        (set! info (build-string "Sphere: " (list-ref line 2) ", Radius=" (remove-carriage-return(list-ref line 4)) "\n\tSurface Area: " (list-ref line 1) ", Volume: " (list-ref line 0)))
      )
    )
   info
  )
)
(define (copy-2d-list lst)
  (define (copy-row row)
    (list->vector (map (lambda (elem) elem) row)))
  (map copy-row lst))

(define (process-cond lines elem1 elem2 elem3)
  (let ((newLines '()))
    (cond 
      ((string=? elem1 "type")
        (cond ((string=? elem2 ">")
                (for-each (lambda (line)
                  (if (string>? (list-ref line 4) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "==")
                (for-each (lambda (line)
                  (if (string=? (list-ref line 4) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "<")
                (for-each (lambda (line)
                  (if (string<? (list-ref line 4) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "<=")
                (for-each (lambda (line)
                  (if (not (string>? (list-ref line 4)) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 ">=")
                (for-each (lambda (line)
                  (if (not (< (string<? (list-ref line 4)) elem3))
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
        )
      )
      ((string=? elem1 "area")
        (cond ((string=? elem2 ">")
                (for-each (lambda (line)
                  (if (> (string->number (list-ref line 2)) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "==")
                (for-each (lambda (line)
                  (if (= (string->number (list-ref line 2)) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "<")
                (for-each (lambda (line)
                  (if (< (string->number (list-ref line 2)) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "<=")
                (for-each (lambda (line)
                  (if (not (> (string->number (list-ref line 2)) elem3))
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 ">=")
                (for-each (lambda (line)
                  (if (not (< (string->number (list-ref line 2)) elem3))
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
          )
      )
      ((string=? elem1 "volume")
        (cond ((string=? elem2 ">")
                (for-each (lambda (line)
                  (if (> (string->number (list-ref line 1)) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "=")
                (for-each (lambda (line)
                  (if (= (string->number (list-ref line 1)) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "<")
                (for-each (lambda (line)
                  (if (< (string->number (list-ref line 1)) elem3)
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 "<=")
                (for-each (lambda (line)
                  (if (not (> (string->number (list-ref line 1)) elem3))
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
              ((string=? elem2 ">=")
                (for-each (lambda (line)
                  (if (not (< (string->number (list-ref line 1)) elem3))
                     (set! newLines (cons line newLines)))) lines
                )
                (set! lines newLines)
              )
        )
      )
    )
    lines
  )
)

(define (print-stuff lines action)
  (cond 
    ((string=? action "print")
      (newline)
      (for-each (lambda (line)
            (display (car line))
            (newline))
          (reverse lines))
    )
    ((string=? action "count")
      (display (string-append "\nThere are " (number->string (length lines)) " shapes.\n"))
    )
    ((string=? action "total")
       (let ((totalArea 0) (totalVolume 0))
        (for-each (lambda (line)
                    (let ((area (string->number (list-ref line 2)))
                          (volume (string->number (list-ref line 1))))
                      (set! totalArea (+ totalArea area))
                      (set! totalVolume (+ totalVolume volume))))
                  lines)
      (display (string-append "\ntotal(Surface Area)=" (number->string totalArea) "\ntotal(Volume)=" (number->string totalVolume) "\n")))
    )
    ((string=? action "min")
      (let ((minArea (string->number (list-ref (list-ref lines 0) 2))) (minVolume (string->number (list-ref (list-ref lines 0) 1))))
        (for-each (lambda (line)
            (if (< (string->number (list-ref line 2)) minArea)
                (set! minArea (string->number (list-ref line 2))))
            (if (< (string->number (list-ref line 1)) minVolume)
                (set! minVolume (string->number (list-ref line 1)))))
          lines)
        (display (string-append "\nmin(Surface Area)= " (number->string minArea) "\nmin(Volume)=" (number->string minVolume) "\n"))))

    ((string=? action "max")
       (let ((maxArea (string->number (list-ref (list-ref lines 0) 2))) (maxVolume (string->number (list-ref (list-ref lines 0) 1))))
        (for-each (lambda (line)
            (if (> (string->number (list-ref line 2)) maxArea)
                (set! maxArea (string->number (list-ref line 2))))
            (if (> (string->number (list-ref line 1)) maxVolume)
                (set! maxVolume (string->number (list-ref line 1)))))
          lines)
        (display (string-append "\nmax(Surface Area)= " (number->string maxArea) "\nmax(Volume)=" (number->string maxVolume) "\n"))))

    ((string=? action "avg")
       (let ((totalArea 0) (totalVolume 0))
        (for-each (lambda (line)
                    (let ((area (string->number (list-ref line 2)))
                          (volume (string->number (list-ref line 1))))
                      (set! totalArea (+ totalArea area))
                      (set! totalVolume (+ totalVolume volume))))
                  lines)
      (let ((avgArea 0) (avgVolume 0) (l (length lines)))
        (set! avgArea (/ totalArea l))
        (set! avgVolume (/ totalVolume l))
        (display (string-append "\navg(Surface Area) = " (number->string avgArea) "\navg(Volume) = " (number->string avgVolume) "\n")))
      )
    )
  )
)

(define (iterate-2d-list action lines args)
  (let ((num-rows (length args))
        (num-cols (length (car args))))
    (do ((i 0 (+ i 1)))
        ((>= i num-rows))
      (do ((j 0 (+ j 3)))
          ((>= j num-cols))
        (let ((elem1 (list-ref (list-ref args i) j))
              (elem2 (list-ref (list-ref args i) (+ j 1)))
              (elem3 (list-ref (list-ref args i) (+ j 2))))
              (set! lines (process-cond lines elem1 elem2 elem3))
        )
      )
    )
  )
  (print-stuff lines action)
)

(define (display-stuff action lines . rest-args)
  (if (not (null? rest-args))
      (iterate-2d-list action lines rest-args)
      (print-stuff lines action)
  )
)

(define (perform action fileName . rest-args)
  (if (not (file-exists? fileName))
      (begin
        (display (string-append "\nUnable to open " fileName " for reading.\n\n"))
        #f)
      (begin
        (let ((lines '()))
          (let ((input-port (open-input-file fileName)))
            (let loop ((line (read-line input-port)))
              (cond ((eof-object? line)
                  (close-input-port input-port))
                  (else
                    ; (newline)
                    (set! line (split-string line))
                    (let ((area (get-area line)))
                      (set! line (cons area line)))
                    (let ((volume (get-volume line)))
                      (set! line (cons volume line)))
                    (let ((info (get-info line)))
                      ; (display info))
                      (set! line (cons info line)))
                    (set! lines (cons line lines))
                    (loop (read-line input-port))
                  )
              )
            )
          )
          (if (null? rest-args)
            ; pass to the action without args
            (begin
              (print-stuff lines action)
            )
            ; if rest-args are provided
            (begin 
              (if (not (check-length rest-args))
                (begin
                  (display "Incorrect number of arguments.")
                  (newline)
                  #f
                )
                (begin
                  (display-stuff action lines rest-args)
                )
              )
            )
          )
        )
      )
   )
)




